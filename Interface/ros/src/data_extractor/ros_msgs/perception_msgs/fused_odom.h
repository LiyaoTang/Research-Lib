// Generated by gencpp from file perception_msgs/fused_odom.msg
// DO NOT EDIT!


#ifndef PERCEPTION_MSGS_MESSAGE_FUSED_ODOM_H
#define PERCEPTION_MSGS_MESSAGE_FUSED_ODOM_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>

#include <std_msgs/Header.h>
#include <perception_msgs/guide_point.h>

namespace perception_msgs
{
template <class ContainerAllocator>
struct fused_odom_
{
  typedef fused_odom_<ContainerAllocator> Type;

  fused_odom_()
    : header()
    , time_ms(0)
    , time_us(0)
    , time_ns(0)
    , time_s_recall_dt(0.0)
    , longitude(0.0)
    , latitude(0.0)
    , mercator_x(0.0)
    , mercator_y(0.0)
    , mercator_z(0.0)
    , acc_x_filtered(0.0)
    , acc_y_filtered(0.0)
    , acc_z_filtered(0.0)
    , gyro_x_filtered(0.0)
    , gyro_y_filtered(0.0)
    , gyro_z_filtered(0.0)
    , vel_x(0.0)
    , vel_y(0.0)
    , vel_z(0.0)
    , roll(0.0)
    , pitch(0.0)
    , yaw(0.0)
    , gyro_bias_x(0.0)
    , gyro_bias_y(0.0)
    , gyro_bias_z(0.0)
    , acc_scale_x(0.0)
    , acc_scale_y(0.0)
    , acc_scale_z(0.0)
    , acc_bias_x(0.0)
    , acc_bias_y(0.0)
    , acc_bias_z(0.0)
    , q1(0.0)
    , q2(0.0)
    , q3(0.0)
    , q4(0.0)
    , yaw_rad(0.0)
    , speed(0.0)
    , current_day_sec(0.0)
    , px2_time_us(0)
    , gps_longitude(0.0)
    , gps_latitude(0.0)
    , gps_heading(0.0)
    , gps_speed(0.0)
    , gps_utc_time_us(0)
    , section_id(0)
    , lane_id(0)
    , odom_healthy(false)
    , guide_point()  {
    }
  fused_odom_(const ContainerAllocator& _alloc)
    : header(_alloc)
    , time_ms(0)
    , time_us(0)
    , time_ns(0)
    , time_s_recall_dt(0.0)
    , longitude(0.0)
    , latitude(0.0)
    , mercator_x(0.0)
    , mercator_y(0.0)
    , mercator_z(0.0)
    , acc_x_filtered(0.0)
    , acc_y_filtered(0.0)
    , acc_z_filtered(0.0)
    , gyro_x_filtered(0.0)
    , gyro_y_filtered(0.0)
    , gyro_z_filtered(0.0)
    , vel_x(0.0)
    , vel_y(0.0)
    , vel_z(0.0)
    , roll(0.0)
    , pitch(0.0)
    , yaw(0.0)
    , gyro_bias_x(0.0)
    , gyro_bias_y(0.0)
    , gyro_bias_z(0.0)
    , acc_scale_x(0.0)
    , acc_scale_y(0.0)
    , acc_scale_z(0.0)
    , acc_bias_x(0.0)
    , acc_bias_y(0.0)
    , acc_bias_z(0.0)
    , q1(0.0)
    , q2(0.0)
    , q3(0.0)
    , q4(0.0)
    , yaw_rad(0.0)
    , speed(0.0)
    , current_day_sec(0.0)
    , px2_time_us(0)
    , gps_longitude(0.0)
    , gps_latitude(0.0)
    , gps_heading(0.0)
    , gps_speed(0.0)
    , gps_utc_time_us(0)
    , section_id(0)
    , lane_id(0)
    , odom_healthy(false)
    , guide_point(_alloc)  {
  (void)_alloc;
    }



   typedef  ::std_msgs::Header_<ContainerAllocator>  _header_type;
  _header_type header;

   typedef uint64_t _time_ms_type;
  _time_ms_type time_ms;

   typedef uint64_t _time_us_type;
  _time_us_type time_us;

   typedef uint64_t _time_ns_type;
  _time_ns_type time_ns;

   typedef double _time_s_recall_dt_type;
  _time_s_recall_dt_type time_s_recall_dt;

   typedef double _longitude_type;
  _longitude_type longitude;

   typedef double _latitude_type;
  _latitude_type latitude;

   typedef double _mercator_x_type;
  _mercator_x_type mercator_x;

   typedef double _mercator_y_type;
  _mercator_y_type mercator_y;

   typedef double _mercator_z_type;
  _mercator_z_type mercator_z;

   typedef double _acc_x_filtered_type;
  _acc_x_filtered_type acc_x_filtered;

   typedef double _acc_y_filtered_type;
  _acc_y_filtered_type acc_y_filtered;

   typedef double _acc_z_filtered_type;
  _acc_z_filtered_type acc_z_filtered;

   typedef double _gyro_x_filtered_type;
  _gyro_x_filtered_type gyro_x_filtered;

   typedef double _gyro_y_filtered_type;
  _gyro_y_filtered_type gyro_y_filtered;

   typedef double _gyro_z_filtered_type;
  _gyro_z_filtered_type gyro_z_filtered;

   typedef double _vel_x_type;
  _vel_x_type vel_x;

   typedef double _vel_y_type;
  _vel_y_type vel_y;

   typedef double _vel_z_type;
  _vel_z_type vel_z;

   typedef double _roll_type;
  _roll_type roll;

   typedef double _pitch_type;
  _pitch_type pitch;

   typedef double _yaw_type;
  _yaw_type yaw;

   typedef double _gyro_bias_x_type;
  _gyro_bias_x_type gyro_bias_x;

   typedef double _gyro_bias_y_type;
  _gyro_bias_y_type gyro_bias_y;

   typedef double _gyro_bias_z_type;
  _gyro_bias_z_type gyro_bias_z;

   typedef double _acc_scale_x_type;
  _acc_scale_x_type acc_scale_x;

   typedef double _acc_scale_y_type;
  _acc_scale_y_type acc_scale_y;

   typedef double _acc_scale_z_type;
  _acc_scale_z_type acc_scale_z;

   typedef double _acc_bias_x_type;
  _acc_bias_x_type acc_bias_x;

   typedef double _acc_bias_y_type;
  _acc_bias_y_type acc_bias_y;

   typedef double _acc_bias_z_type;
  _acc_bias_z_type acc_bias_z;

   typedef double _q1_type;
  _q1_type q1;

   typedef double _q2_type;
  _q2_type q2;

   typedef double _q3_type;
  _q3_type q3;

   typedef double _q4_type;
  _q4_type q4;

   typedef double _yaw_rad_type;
  _yaw_rad_type yaw_rad;

   typedef double _speed_type;
  _speed_type speed;

   typedef double _current_day_sec_type;
  _current_day_sec_type current_day_sec;

   typedef int64_t _px2_time_us_type;
  _px2_time_us_type px2_time_us;

   typedef double _gps_longitude_type;
  _gps_longitude_type gps_longitude;

   typedef double _gps_latitude_type;
  _gps_latitude_type gps_latitude;

   typedef double _gps_heading_type;
  _gps_heading_type gps_heading;

   typedef double _gps_speed_type;
  _gps_speed_type gps_speed;

   typedef uint64_t _gps_utc_time_us_type;
  _gps_utc_time_us_type gps_utc_time_us;

   typedef int64_t _section_id_type;
  _section_id_type section_id;

   typedef int64_t _lane_id_type;
  _lane_id_type lane_id;

   typedef uint8_t _odom_healthy_type;
  _odom_healthy_type odom_healthy;

   typedef  ::perception_msgs::guide_point_<ContainerAllocator>  _guide_point_type;
  _guide_point_type guide_point;





  typedef boost::shared_ptr< ::perception_msgs::fused_odom_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::perception_msgs::fused_odom_<ContainerAllocator> const> ConstPtr;

}; // struct fused_odom_

typedef ::perception_msgs::fused_odom_<std::allocator<void> > fused_odom;

typedef boost::shared_ptr< ::perception_msgs::fused_odom > fused_odomPtr;
typedef boost::shared_ptr< ::perception_msgs::fused_odom const> fused_odomConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::perception_msgs::fused_odom_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::perception_msgs::fused_odom_<ContainerAllocator> >::stream(s, "", v);
return s;
}

} // namespace perception_msgs

namespace ros
{
namespace message_traits
{



// BOOLTRAITS {'IsFixedSize': False, 'IsMessage': True, 'HasHeader': True}
// {'perception_msgs': ['/home/shawn/baidu/ai-auto/l3-apollo/catkin_build/src/modules/ros_msgs/perception/msg'], 'std_msgs': ['/opt/ros/kinetic/share/std_msgs/cmake/../msg']}

// !!!!!!!!!!! ['__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_parsed_fields', 'constants', 'fields', 'full_name', 'has_header', 'header_present', 'names', 'package', 'parsed_fields', 'short_name', 'text', 'types']




template <class ContainerAllocator>
struct IsFixedSize< ::perception_msgs::fused_odom_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::perception_msgs::fused_odom_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct IsMessage< ::perception_msgs::fused_odom_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::perception_msgs::fused_odom_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::perception_msgs::fused_odom_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::perception_msgs::fused_odom_<ContainerAllocator> const>
  : TrueType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::perception_msgs::fused_odom_<ContainerAllocator> >
{
  static const char* value()
  {
    return "2ccb3ddc43edbe4ae51d68a768d2ea2e";
  }

  static const char* value(const ::perception_msgs::fused_odom_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x2ccb3ddc43edbe4aULL;
  static const uint64_t static_value2 = 0xe51d68a768d2ea2eULL;
};

template<class ContainerAllocator>
struct DataType< ::perception_msgs::fused_odom_<ContainerAllocator> >
{
  static const char* value()
  {
    return "perception_msgs/fused_odom";
  }

  static const char* value(const ::perception_msgs::fused_odom_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::perception_msgs::fused_odom_<ContainerAllocator> >
{
  static const char* value()
  {
    return "Header header\n\
uint64 time_ms\n\
uint64 time_us\n\
uint64 time_ns\n\
float64 time_s_recall_dt   # delta time recall_time - called_time in second(s)\n\
float64 longitude   # odom longitude\n\
float64 latitude    # odom latitude\n\
\n\
#  y(north)\n\
#  ^\n\
#  |\n\
#  | \n\
#  o------>x(east)\n\
float64 mercator_x  # odom mercator_x\n\
float64 mercator_y  # odom mercator_y\n\
float64 mercator_z  # odom mercator_z\n\
float64 acc_x_filtered\n\
float64 acc_y_filtered\n\
float64 acc_z_filtered\n\
float64 gyro_x_filtered\n\
float64 gyro_y_filtered\n\
float64 gyro_z_filtered\n\
float64 vel_x\n\
float64 vel_y\n\
float64 vel_z\n\
float64 roll\n\
float64 pitch\n\
float64 yaw\n\
float64 gyro_bias_x\n\
float64 gyro_bias_y\n\
float64 gyro_bias_z\n\
float64 acc_scale_x\n\
float64 acc_scale_y\n\
float64 acc_scale_z\n\
float64 acc_bias_x\n\
float64 acc_bias_y\n\
float64 acc_bias_z\n\
# quaternion\n\
float64 q1\n\
float64 q2\n\
float64 q3\n\
float64 q4\n\
float64 yaw_rad     # rad/s\n\
float64 speed       # m/s\n\
float64 current_day_sec # current_day_second\n\
int64 px2_time_us   # \n\
\n\
# gps\n\
float64 gps_longitude\n\
float64 gps_latitude\n\
float64 gps_heading\n\
float64 gps_speed\n\
uint64  gps_utc_time_us\n\
\n\
int64 section_id    # section_id in had map, if not valid, return -1\n\
int64 lane_id       # lane id in had map, if not valid, return -1\n\
\n\
bool  odom_healthy  # indicate odom health status\n\
\n\
# guide_point, last localization result\n\
perception_msgs/guide_point guide_point\n\
\n\
================================================================================\n\
MSG: std_msgs/Header\n\
# Standard metadata for higher-level stamped data types.\n\
# This is generally used to communicate timestamped data \n\
# in a particular coordinate frame.\n\
# \n\
# sequence ID: consecutively increasing ID \n\
uint32 seq\n\
#Two-integer timestamp that is expressed as:\n\
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')\n\
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')\n\
# time-handling sugar is provided by the client library\n\
time stamp\n\
#Frame this data is associated with\n\
# 0: no frame\n\
# 1: global frame\n\
string frame_id\n\
\n\
================================================================================\n\
MSG: perception_msgs/guide_point\n\
# GuidancePointType type;\n\
# double distance;\n\
# int lane_id;\n\
# int section_id;\n\
# GPSCoord gps_coord;\n\
\n\
int64 guide_point_type\n\
float64 distance\n\
int64 lane_id\n\
int64 section_id\n\
float64 gps_longitude\n\
float64 gps_latitude\n\
";
  }

  static const char* value(const ::perception_msgs::fused_odom_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::perception_msgs::fused_odom_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.header);
      stream.next(m.time_ms);
      stream.next(m.time_us);
      stream.next(m.time_ns);
      stream.next(m.time_s_recall_dt);
      stream.next(m.longitude);
      stream.next(m.latitude);
      stream.next(m.mercator_x);
      stream.next(m.mercator_y);
      stream.next(m.mercator_z);
      stream.next(m.acc_x_filtered);
      stream.next(m.acc_y_filtered);
      stream.next(m.acc_z_filtered);
      stream.next(m.gyro_x_filtered);
      stream.next(m.gyro_y_filtered);
      stream.next(m.gyro_z_filtered);
      stream.next(m.vel_x);
      stream.next(m.vel_y);
      stream.next(m.vel_z);
      stream.next(m.roll);
      stream.next(m.pitch);
      stream.next(m.yaw);
      stream.next(m.gyro_bias_x);
      stream.next(m.gyro_bias_y);
      stream.next(m.gyro_bias_z);
      stream.next(m.acc_scale_x);
      stream.next(m.acc_scale_y);
      stream.next(m.acc_scale_z);
      stream.next(m.acc_bias_x);
      stream.next(m.acc_bias_y);
      stream.next(m.acc_bias_z);
      stream.next(m.q1);
      stream.next(m.q2);
      stream.next(m.q3);
      stream.next(m.q4);
      stream.next(m.yaw_rad);
      stream.next(m.speed);
      stream.next(m.current_day_sec);
      stream.next(m.px2_time_us);
      stream.next(m.gps_longitude);
      stream.next(m.gps_latitude);
      stream.next(m.gps_heading);
      stream.next(m.gps_speed);
      stream.next(m.gps_utc_time_us);
      stream.next(m.section_id);
      stream.next(m.lane_id);
      stream.next(m.odom_healthy);
      stream.next(m.guide_point);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct fused_odom_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::perception_msgs::fused_odom_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::perception_msgs::fused_odom_<ContainerAllocator>& v)
  {
    s << indent << "header: ";
    s << std::endl;
    Printer< ::std_msgs::Header_<ContainerAllocator> >::stream(s, indent + "  ", v.header);
    s << indent << "time_ms: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.time_ms);
    s << indent << "time_us: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.time_us);
    s << indent << "time_ns: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.time_ns);
    s << indent << "time_s_recall_dt: ";
    Printer<double>::stream(s, indent + "  ", v.time_s_recall_dt);
    s << indent << "longitude: ";
    Printer<double>::stream(s, indent + "  ", v.longitude);
    s << indent << "latitude: ";
    Printer<double>::stream(s, indent + "  ", v.latitude);
    s << indent << "mercator_x: ";
    Printer<double>::stream(s, indent + "  ", v.mercator_x);
    s << indent << "mercator_y: ";
    Printer<double>::stream(s, indent + "  ", v.mercator_y);
    s << indent << "mercator_z: ";
    Printer<double>::stream(s, indent + "  ", v.mercator_z);
    s << indent << "acc_x_filtered: ";
    Printer<double>::stream(s, indent + "  ", v.acc_x_filtered);
    s << indent << "acc_y_filtered: ";
    Printer<double>::stream(s, indent + "  ", v.acc_y_filtered);
    s << indent << "acc_z_filtered: ";
    Printer<double>::stream(s, indent + "  ", v.acc_z_filtered);
    s << indent << "gyro_x_filtered: ";
    Printer<double>::stream(s, indent + "  ", v.gyro_x_filtered);
    s << indent << "gyro_y_filtered: ";
    Printer<double>::stream(s, indent + "  ", v.gyro_y_filtered);
    s << indent << "gyro_z_filtered: ";
    Printer<double>::stream(s, indent + "  ", v.gyro_z_filtered);
    s << indent << "vel_x: ";
    Printer<double>::stream(s, indent + "  ", v.vel_x);
    s << indent << "vel_y: ";
    Printer<double>::stream(s, indent + "  ", v.vel_y);
    s << indent << "vel_z: ";
    Printer<double>::stream(s, indent + "  ", v.vel_z);
    s << indent << "roll: ";
    Printer<double>::stream(s, indent + "  ", v.roll);
    s << indent << "pitch: ";
    Printer<double>::stream(s, indent + "  ", v.pitch);
    s << indent << "yaw: ";
    Printer<double>::stream(s, indent + "  ", v.yaw);
    s << indent << "gyro_bias_x: ";
    Printer<double>::stream(s, indent + "  ", v.gyro_bias_x);
    s << indent << "gyro_bias_y: ";
    Printer<double>::stream(s, indent + "  ", v.gyro_bias_y);
    s << indent << "gyro_bias_z: ";
    Printer<double>::stream(s, indent + "  ", v.gyro_bias_z);
    s << indent << "acc_scale_x: ";
    Printer<double>::stream(s, indent + "  ", v.acc_scale_x);
    s << indent << "acc_scale_y: ";
    Printer<double>::stream(s, indent + "  ", v.acc_scale_y);
    s << indent << "acc_scale_z: ";
    Printer<double>::stream(s, indent + "  ", v.acc_scale_z);
    s << indent << "acc_bias_x: ";
    Printer<double>::stream(s, indent + "  ", v.acc_bias_x);
    s << indent << "acc_bias_y: ";
    Printer<double>::stream(s, indent + "  ", v.acc_bias_y);
    s << indent << "acc_bias_z: ";
    Printer<double>::stream(s, indent + "  ", v.acc_bias_z);
    s << indent << "q1: ";
    Printer<double>::stream(s, indent + "  ", v.q1);
    s << indent << "q2: ";
    Printer<double>::stream(s, indent + "  ", v.q2);
    s << indent << "q3: ";
    Printer<double>::stream(s, indent + "  ", v.q3);
    s << indent << "q4: ";
    Printer<double>::stream(s, indent + "  ", v.q4);
    s << indent << "yaw_rad: ";
    Printer<double>::stream(s, indent + "  ", v.yaw_rad);
    s << indent << "speed: ";
    Printer<double>::stream(s, indent + "  ", v.speed);
    s << indent << "current_day_sec: ";
    Printer<double>::stream(s, indent + "  ", v.current_day_sec);
    s << indent << "px2_time_us: ";
    Printer<int64_t>::stream(s, indent + "  ", v.px2_time_us);
    s << indent << "gps_longitude: ";
    Printer<double>::stream(s, indent + "  ", v.gps_longitude);
    s << indent << "gps_latitude: ";
    Printer<double>::stream(s, indent + "  ", v.gps_latitude);
    s << indent << "gps_heading: ";
    Printer<double>::stream(s, indent + "  ", v.gps_heading);
    s << indent << "gps_speed: ";
    Printer<double>::stream(s, indent + "  ", v.gps_speed);
    s << indent << "gps_utc_time_us: ";
    Printer<uint64_t>::stream(s, indent + "  ", v.gps_utc_time_us);
    s << indent << "section_id: ";
    Printer<int64_t>::stream(s, indent + "  ", v.section_id);
    s << indent << "lane_id: ";
    Printer<int64_t>::stream(s, indent + "  ", v.lane_id);
    s << indent << "odom_healthy: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.odom_healthy);
    s << indent << "guide_point: ";
    s << std::endl;
    Printer< ::perception_msgs::guide_point_<ContainerAllocator> >::stream(s, indent + "  ", v.guide_point);
  }
};

} // namespace message_operations
} // namespace ros

#endif // PERCEPTION_MSGS_MESSAGE_FUSED_ODOM_H
